import {
  computed,
  createElementBlock,
  defineComponent,
  openBlock,
  ref,
  resolveDirective,
  watch,
  withDirectives
} from "./chunk-U3LI7FBV.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/@coders-tm/vue-number-format/dist/index.mjs
var a = { prefix: "", suffix: "", separator: ",", decimal: ".", inputmode: "numeric", precision: 2, minimumFractionDigits: null, prefill: true, reverseFill: false, min: null, max: null, nullValue: "" };
function o(e) {
  return t = 0, i = e, n = 20, Math.max(t, Math.min(i, n));
  var t, i, n;
}
var p = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "input");
    __publicField(this, "number");
    __publicField(this, "isClean");
    __publicField(this, "isCustomDecimal");
    __publicField(this, "noPreSuffix");
    __publicField(this, "hasPreOrSuffix");
    __publicField(this, "prefix");
    __publicField(this, "preSufRegExp");
    __publicField(this, "prefixRegExp");
    __publicField(this, "suffixRegExp");
    __publicField(this, "numberRegExp");
    __publicField(this, "cleanRegExp");
    __publicField(this, "negativeRegExp");
    this.options = Object.assign(c(a), e);
    const { prefix: t, suffix: i, decimal: n, reverseFill: r } = this.options;
    this.input = "", this.number = "", this.isClean = !r;
    const u = t, s = i, l = u.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), o2 = s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    l && (this.prefixRegExp = new RegExp(`^${l}`)), o2 && (this.suffixRegExp = new RegExp(`${o2}$`)), this.prefix = t, this.numberRegExp = new RegExp(`[^0-9\\${n}]+`, "gi"), this.cleanRegExp = new RegExp("[^0-9]+", "gi"), this.negativeRegExp = new RegExp("[^0-9\\-]+", "gi"), this.isCustomDecimal = "." !== n, this.noPreSuffix = !u && !s, this.hasPreOrSuffix = !this.noPreSuffix;
  }
  isNull() {
    return !this.numberOnly(this.isClean ? this.cleanRegExp : this.negativeRegExp);
  }
  clean(e = false) {
    return this.isClean = e, this;
  }
  sign() {
    if (null === this.input || void 0 === this.input) return "";
    const e = this.input.toString().indexOf(m) >= 0;
    return this.isClean ? e && this.realNumber() > 0 ? m : "" : e ? m : "";
  }
  toFixed() {
    const e = Math.pow(10, this.options.precision);
    return (parseFloat(this.numberOnly(/\D+/g)) / e || 0).toFixed(o(this.options.precision));
  }
  toNumber(e) {
    return Number(e);
  }
  numberOnly(e) {
    var _a;
    let t = (_a = this.input) == null ? void 0 : _a.toString();
    return this.prefixRegExp && (t = t.replace(this.prefixRegExp, "")), this.suffixRegExp && (t = t.replace(this.suffixRegExp, "")), t.replace(e || this.numberRegExp, "");
  }
  inputWithPreOrSuffix() {
    return this.input && this.prefixRegExp ? this.prefixRegExp.test(this.input.toString()) : !this.input || !this.suffixRegExp || this.suffixRegExp.test(this.input.toString());
  }
  isNegative() {
    return this.sign() === m;
  }
  isNumber(e) {
    return !isNaN(this.toNumber(e || this.input));
  }
  numbers() {
    var _a;
    const { reverseFill: e, decimal: t, separator: i } = this.options;
    if (e) this.number = this.toFixed().replace(".", t);
    else {
      const e2 = (_a = this.input) == null ? void 0 : _a.toString().replace(this.prefixRegExp ?? "", "").replace(this.suffixRegExp ?? "", "").replace(new RegExp(m, "g"), ""), n = this.input.toString().indexOf(t) >= 0 && this.isCustomDecimal, r = e2.replace(new RegExp(`\\${i}`, "g"), "").replace(t, ".");
      "number" == typeof this.input || this.isNumber() && !n && !this.inputWithPreOrSuffix() && this.hasPreOrSuffix ? this.number = this.parts(e2, ".").join(t) : this.isNumber(r) && !n && this.inputWithPreOrSuffix() && this.hasPreOrSuffix ? this.number = this.parts(r, ".").join(t) : this.number = this.parts(this.numberOnly()).join(t);
    }
    return this.number;
  }
  unformatNumber() {
    return this.numbers().toString().replace(this.options.decimal, ".");
  }
  realNumber() {
    return parseFloat(this.unformatNumber());
  }
  parts(e, t) {
    const { precision: i, minimumFractionDigits: n, decimal: r } = this.options;
    let u = e.toString().split(t || r);
    if (u.length > 1 && (u[0] = this.toNumber(u[0]) || 0, u[1] = u.slice(1, u.length).join(""), u = u.slice(0, 2)), this.isClean) {
      const e2 = this.toNumber(u.join(".")).toFixed(i), t2 = this.toNumber(e2), r2 = t2.toFixed(n);
      u = n >= 0 && t2.toString().length < r2.length ? r2.toString().split(".") : t2.toString().split(".");
    }
    return u.slice(0, 2);
  }
  addSeparator() {
    const { decimal: e, separator: t } = this.options, i = this.numbers().split(e);
    return i[0] = i[0].toString().replace(/(\d)(?=(?:\d{3})+\b)/gm, `$1${t}`), i.join(e);
  }
  format(e) {
    this.input = e;
    const { reverseFill: t, nullValue: i, prefix: n, suffix: r } = this.options;
    return this.isNull() && !t ? i : this.sign() + n + this.addSeparator() + r;
  }
  unformat(e) {
    this.input = e;
    const { reverseFill: t, nullValue: i } = this.options, n = this.realNumber(), r = this.unformatNumber();
    return this.isNull() || t && 0 === n ? i : this.sign() + r;
  }
};
var m = "-";
function c(e) {
  return JSON.parse(JSON.stringify(e));
}
function f(e) {
  return new CustomEvent(e, { bubbles: true, cancelable: true, detail: { facade: true } });
}
function h(e) {
  const t = e instanceof HTMLInputElement ? e : e.querySelector("input");
  if (!t) throw new Error("number directive requires an input element");
  return t;
}
function d(e, t) {
  const i = () => {
    e.setSelectionRange(t, t);
  };
  i(), setTimeout(i, 1);
}
function g(e, t, { emit: i = true, force: n = false, clean: r = false } = {}) {
  var _a;
  const { options: u, oldValue: s } = e, { reverseFill: l, max: a2, min: o2 } = u, m2 = ((_a = t == null ? void 0 : t.props) == null ? void 0 : _a.value) || e.value;
  if (n || s !== m2) {
    const t2 = new p(u).clean(r && !l);
    let i2 = t2.format(m2), n2 = t2.clean(!l).unformat(m2);
    r && (Number(a2) === a2 && Number(n2) > a2 ? (i2 = t2.format(a2), n2 = a2.toString()) : Number(o2) === o2 && Number(n2) < o2 && (i2 = t2.format(o2), n2 = o2.toString())), e.oldValue = i2, e.unmasked = n2, e.value !== i2 && (e.value = i2);
  }
  return i && e.dispatchEvent(f("input"));
}
var v = { beforeMount: (e, { value: t, modifiers: i }, n) => {
  var _a;
  e = h(e);
  const r = Object.assign(c(a), t, i), { reverseFill: u, precision: s, decimal: l, inputmode: o2 } = r;
  e.options = r, e.setAttribute("inputmode", o2), u && e.value ? (e.value = parseFloat(new p({ ...r, reverseFill: false }).unformat(e.value)).toFixed(s), ((_a = n == null ? void 0 : n.props) == null ? void 0 : _a.value) && (n.props.value = e.value)) : e.value && !isNaN(Number(e.value)) && (e.value = e.value.replace(".", l)), g(e, n, { force: r.prefill, clean: true, emit: false });
}, mounted: (e) => {
  const t = (e = h(e)).parentElement || e, i = (t2) => {
    t2.target === e && function(e2) {
      const { target: t3, detail: i2 } = e2;
      if (i2 == null ? void 0 : i2.facade) return false;
      e2.stopPropagation();
      let n2 = t3.value.length;
      const { oldValue: r2, options: u } = t3;
      t3.selectionEnd && (n2 = t3.value.length - t3.selectionEnd), g(t3, null, { clean: !u.precision, emit: false }), u.suffix && (n2 = Math.max(n2, u.suffix.length)), n2 = t3.value.length - n2, u.prefix && (n2 = Math.max(n2, u.prefix.length)), d(t3, n2), r2 !== t3.value && t3.dispatchEvent(f("input"));
    }(t2);
  }, n = (t2) => {
    t2.target === e && function(e2) {
      const { target: t3 } = e2, { oldValue: i2 } = t3;
      g(t3, null, { force: true, clean: true, emit: false }), i2 !== t3.value && t3.dispatchEvent(f("input"));
    }(t2);
  }, r = (t2) => {
    t2.target === e && function(e2, t3) {
      const { options: i2 } = t3, { prefix: n2, suffix: r2, decimal: u, min: s, separator: l } = i2, { key: a2 } = e2, o2 = new RegExp(`${n2}|${r2}`, "g"), p2 = t3.value.replace(o2, ""), c2 = void 0 === s || Number(s) < 0 || Number(s) !== s;
      if (a2 === u) p2.includes(u) ? e2.preventDefault() : p2 || (t3.value = "0", t3.dispatchEvent(new Event("input")));
      else if (a2 !== m || c2) {
        if ("Backspace" === a2) {
          const i3 = t3.selectionEnd || 0, u2 = t3.value.slice(i3 - 1, i3), s2 = t3.value.slice(i3 - 2, i3);
          let a3 = t3.value.length - i3;
          [n2, m, l].includes(u2) && (e2.preventDefault(), t3.value = u2 === l ? t3.value.replace(s2, "") : t3.value.replace(new RegExp(`[${n2}${m}]`, "g"), ""), a3 = Math.max(a3, r2.length), a3 = t3.value.length - a3, a3 = Math.max(a3, n2.length), d(t3, a3), t3.dispatchEvent(new Event("input")));
        }
      } else e2.preventDefault();
    }(t2, e);
  };
  t.addEventListener("input", i, true), t.addEventListener("blur", n, true), t.addEventListener("keydown", r, true), e.cleanup = () => {
    t.removeEventListener("input", i, true), t.removeEventListener("blur", n, true), t.removeEventListener("keydown", r, true);
  };
}, updated: (e, { value: t, oldValue: i, modifiers: n }, r) => {
  if (e = h(e), t !== i) {
    const i2 = e.options;
    e.options = Object.assign(i2, t, n), g(e, r, { force: true, clean: false, emit: false });
  } else g(e, r, { emit: false });
}, unmounted: (e) => {
  var _a;
  (_a = h(e)) == null ? void 0 : _a.cleanup();
} };
var x = c(a);
var b = defineComponent({ name: "VueNumber", directives: { number: v }, props: { modelValue: { type: [String, Number], required: true }, nullValue: { type: [Number, String], default: x.nullValue }, masked: Boolean, readonly: Boolean, disabled: Boolean, reverseFill: { type: Boolean, default: x.reverseFill }, prefill: { type: Boolean, default: x.prefill }, precision: { type: Number, default: () => x.precision }, minimumFractionDigits: { type: Number, default: () => x.minimumFractionDigits }, decimal: { type: String, default: () => x.decimal }, min: { type: Number, default: () => x.min }, max: { type: Number, default: () => x.max }, separator: { type: String, default: () => x.separator }, prefix: { type: String, default: () => x.prefix }, suffix: { type: String, default: () => x.suffix }, inputmode: { type: String, default: () => x.inputmode } }, emits: ["update:model-value", "input:model-value"], setup(e, { emit: r }) {
  const u = ref(e.modelValue), s = ref(false), l = ref(""), a2 = computed(() => ({ ...e })), o2 = new p(a2.value), m2 = computed(() => e.masked ? o2.format(u.value) : l.value), c2 = () => {
    r("update:model-value", m2.value);
  };
  return watch(() => e.modelValue, (e2) => {
    m2.value != e2 && (u.value = o2.format(e2));
  }), { config: a2, maskedValue: u, unmaskedValue: l, input: (e2) => {
    const { target: t } = e2;
    u.value = t.value, l.value = t.unmasked, s.value = true, r("input:model-value", m2.value);
  }, blur: () => {
    s.value && m2.value !== e.modelValue && c2();
  }, change: c2 };
} });
var E = ["value", "readonly", "disabled"];
b.render = function(e, t, i, n, a2, o2) {
  const p2 = resolveDirective("number");
  return withDirectives((openBlock(), createElementBlock("input", { type: "text", autocomplete: "off", value: e.maskedValue, readonly: e.readonly, disabled: e.disabled, class: "v-number vue-number-format", onChange: t[0] || (t[0] = (...t2) => e.change && e.change(...t2)), onInput: t[1] || (t[1] = (...t2) => e.input && e.input(...t2)), onBlur: t[2] || (t[2] = (...t2) => e.blur && e.blur(...t2)) }, null, 40, E)), [[p2, e.config]]);
}, b.__file = "src/component.vue";
var N = { install(e, t) {
  t && Object.assign(a, t), e.directive("number", v), e.component("VueNumber", b);
} };
export {
  p as NumberFormat,
  b as component,
  N as default,
  v as directive,
  a as options
};
/*! Bundled license information:

@coders-tm/vue-number-format/dist/index.mjs:
  (**
   * Vue Number Format 3.34.1
   * (c) 2021-2024 Dipak Sarkar <hello@dipaksarkar.in> (https://dipaksarkar.in/)
   * @license MIT
   *)
*/
//# sourceMappingURL=@coders-tm_vue-number-format.js.map
